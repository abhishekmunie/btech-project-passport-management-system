// Generated by CoffeeScript 1.7.1
var EntityName, PGConnect, TYPE, User, addUser, appCrypto, crypto, debug, deleteFromDatabaseUserForEmail, deleteQuery, email, getSaltForEmail, globals, insertIntoDatabase, removeUser, resetPasswordForUserWithEmail, verifyCredentials;

crypto = require('crypto');

appCrypto = require('../crypto');

globals = require('../globals');

debug = globals.debug;

PGConnect = globals.PGConnect;

email = require('../email');

EntityName = '"passport"."User"';

TYPE = 'User';

User = (function() {
  var insertQuery;

  function User(email) {
    this.email = email;
    this.type = TYPE;
  }

  insertQuery = function(values, client, done, callback) {
    return client.query({
      name: "user_insert",
      text: "INSERT INTO " + EntityName + " VALUES ( $1::varchar , $2::varchar , $3::varchar ) ",
      values: values
    }, function(err, result) {
      if (err) {
        if (typeof done === "function") {
          done(client);
        }
        console.error('error running query', err);
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      if (typeof done === "function") {
        done();
      }
      return typeof callback === "function" ? callback() : void 0;
    });
  };

  return User;

})();

insertIntoDatabase = function(email, password, client, callback) {
  if (typeof client === "function") {
    callback = client;
    client = void 0;
  }
  crypto.randomBytes(126, function(ex, buf) {
    var salt;
    if (ex) {
      return typeof callback === "function" ? callback(ex) : void 0;
    }
    salt = buf.toString('base64');
    appCrypto.genKey(password, salt, function(err, key) {
      if (err) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      if (client != null) {
        insertQuery([email, key, salt], client, null, callback);
      } else {
        PGConnect(function(err, client, done) {
          if (err) {
            if (typeof done === "function") {
              done(client);
            }
            console.error('error fetching client from pool', err);
            if (typeof callback === "function") {
              callback(err);
            }
            return;
          }
          insertQuery([email, key, salt], client, done, callback);
        });
      }
    });
  });
};

getSaltForEmail = function(email, callback) {
  PGConnect(function(err, client, done) {
    if (err) {
      if (typeof done === "function") {
        done(client);
      }
      console.error('error fetching client from pool', err);
      if (typeof callback === "function") {
        callback(err);
      }
      return;
    }
    client.query({
      name: "user_salt",
      text: "SELECT salt FROM " + EntityName + " WHERE \"email\" = $1::varchar ",
      values: [email]
    }, function(err, result) {
      if (err) {
        if (typeof done === "function") {
          done(client);
        }
        console.error('error running query', err);
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      if (typeof done === "function") {
        done();
      }
      if (result.rows[0] != null) {
        if (typeof callback === "function") {
          callback(null, result.rows[0].salt);
        }
      } else {
        if (typeof callback === "function") {
          callback();
        }
      }
    });
  });
};

verifyCredentials = function(email, password, callback) {
  return getSaltForEmail(email, function(err, salt) {
    if (err) {
      return typeof callback === "function" ? callback(err) : void 0;
    }
    if (!salt) {
      return typeof callback === "function" ? callback(null, false) : void 0;
    }
    return appCrypto.genKey(password, salt, function(err, key) {
      if (err) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      return PGConnect(function(err, client, done) {
        if (err) {
          if (typeof done === "function") {
            done(client);
          }
          console.error('error fetching client from pool', err);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        return client.query({
          name: "auth_signin",
          text: "SELECT count(*) AS exists FROM " + EntityName + " WHERE \"email\" = $1::varchar AND \"key\" = $2::varchar ",
          values: [email, key]
        }, function(err, result) {
          if (err) {
            if (typeof done === "function") {
              done(client);
            }
            console.error('error running query', err);
            if (typeof callback === "function") {
              callback(err);
            }
            return;
          }
          if (typeof done === "function") {
            done();
          }
          return typeof callback === "function" ? callback(null, result.rows[0].exists === '1') : void 0;
        });
      });
    });
  });
};

addUser = function(email, password, client, callback) {
  debug("Adding user with email: " + email);
  return insertIntoDatabase(email, password, client, callback);
};

deleteQuery = function(values, client, done, callback) {
  return client.query({
    name: "user_delete",
    text: "DELETE FROM " + EntityName + " WHERE \"email\" = $1::varchar ",
    values: values
  }, function(err, result) {
    if (err) {
      if (typeof done === "function") {
        done(client);
      }
      console.error('error running query', err);
      if (typeof callback === "function") {
        callback(err);
      }
      return;
    }
    if (typeof done === "function") {
      done();
    }
    return typeof callback === "function" ? callback() : void 0;
  });
};

deleteFromDatabaseUserForEmail = function(email, client, callback) {
  if (typeof client === "function") {
    callback = client;
    client = void 0;
  }
  if (client != null) {
    deleteQuery([email], client, null, callback);
  } else {
    PGConnect(function(err, client, done) {
      if (err) {
        if (typeof done === "function") {
          done(client);
        }
        console.error('error fetching client from pool', err);
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      deleteQuery([email], client, done, callback);
    });
  }
};

removeUser = function(email, client, callback) {
  debug("Removing User with email: " + email);
  return deleteFromDatabaseUserForEmail(email, client, callback);
};

resetPasswordForUserWithEmail = function(email, callback) {
  debug("Resetting password for email: " + email);
  return process.nextTick(callback);
};

module.exports = {
  User: User,
  type: TYPE,
  addUser: addUser,
  removeUser: removeUser,
  getSaltForEmail: getSaltForEmail,
  verifyCredentials: verifyCredentials,
  resetPasswordForUserWithEmail: resetPasswordForUserWithEmail
};
